System.register(["./index-legacy-CkvIY1Fm.js"],function(t,e){"use strict";var r,c,y;return{setters:[t=>{r=t.W,c=t.D,y=t.E}],execute:function(){function u(t){const e=t.split("/").filter(t=>"."!==t),r=[];return e.forEach(t=>{".."===t&&0<r.length&&".."!==r[r.length-1]?r.pop():r.push(t)}),r.join("/")}class i extends r{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=async r=>{var i;const a=c(r,r.webFetchExtra),o=await fetch(r.url,a);let s;if(r.progress)if(null!=o&&o.body){const i=o.body.getReader();let t=0;const c=[],a=o.headers.get("content-type"),d=parseInt(o.headers.get("content-length")||"0",10);for(;;){const{done:a,value:o}=await i.read();if(a)break;c.push(o),t+=(null==o?void 0:o.length)||0;const s={url:r.url,bytes:t,contentLength:d};this.notifyListeners("progress",s)}var n=new Uint8Array(t);let e=0;for(const r of c)void 0!==r&&(n.set(r,e),e+=r.length);s=new Blob([n.buffer],{type:a||void 0})}else s=new Blob;else s=await o.blob();return{path:(await this.writeFile({path:r.path,directory:null!=(i=r.directory)?i:void 0,recursive:null!=(i=r.recursive)&&i,data:s})).uri,blob:s}}}async initDb(){if(void 0!==this._db)return this._db;if("indexedDB"in window)return new Promise((t,e)=>{const r=indexedDB.open(this.DB_NAME,this.DB_VERSION);r.onupgradeneeded=i.doUpgrade,r.onsuccess=()=>{this._db=r.result,t(r.result)},r.onerror=()=>e(r.error),r.onblocked=()=>{console.warn("db blocked")}});throw this.unavailable("This browser doesn't support IndexedDB")}static doUpgrade(t){var e=t.target.result;t.oldVersion,e.objectStoreNames.contains("FileStorage")&&e.deleteObjectStore("FileStorage"),e.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}async dbRequest(a,o){const s=-1!==this._writeCmds.indexOf(a)?"readwrite":"readonly";return this.initDb().then(i=>new Promise((t,e)=>{const r=i.transaction(["FileStorage"],s).objectStore("FileStorage")[a](...o);r.onsuccess=()=>t(r.result),r.onerror=()=>e(r.error)}))}async dbIndexRequest(a,o,s){const n=-1!==this._writeCmds.indexOf(o)?"readwrite":"readonly";return this.initDb().then(i=>new Promise((t,e)=>{const r=i.transaction(["FileStorage"],n).objectStore("FileStorage").index(a)[o](...s);r.onsuccess=()=>t(r.result),r.onerror=()=>e(r.error)}))}getPath(t,e){var r=void 0!==e?e.replace(/^[/]+|[/]+$/g,""):"";let i="";return void 0!==t&&(i+="/"+t),""!==e&&(i+="/"+r),i}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(t){t=this.getPath(t.directory,t.path),t=await this.dbRequest("get",[t]);if(void 0===t)throw Error("File does not exist.");return{data:t.content||""}}async writeFile(t){const e=this.getPath(t.directory,t.path);let r=t.data;var i=t.encoding,a=t.recursive,o=await this.dbRequest("get",[e]);if(o&&"directory"===o.type)throw Error("The supplied path is a directory.");o=e.substr(0,e.lastIndexOf("/"));if(void 0===await this.dbRequest("get",[o])){const e=o.indexOf("/",1);if(-1!==e){const r=o.substr(e);await this.mkdir({path:r,directory:t.directory,recursive:a})}}if(i||r instanceof Blob||(r=0<=r.indexOf(",")?r.split(",")[1]:r,this.isBase64String(r)))return t=Date.now(),a={path:e,folder:o,type:"file",size:r instanceof Blob?r.size:r.length,ctime:t,mtime:t,content:r},await this.dbRequest("put",[a]),{uri:a.path};throw Error("The supplied data is not valid base64 content.")}async appendFile(t){const e=this.getPath(t.directory,t.path);let r=t.data;var i=t.encoding,a=e.substr(0,e.lastIndexOf("/")),o=Date.now();let s=o;var n=await this.dbRequest("get",[e]);if(n&&"directory"===n.type)throw Error("The supplied path is a directory.");if(void 0===await this.dbRequest("get",[a])){const e=a.indexOf("/",1);if(-1!==e){const r=a.substr(e);await this.mkdir({path:r,directory:t.directory,recursive:!0})}}if(!i&&!this.isBase64String(r))throw Error("The supplied data is not valid base64 content.");if(void 0!==n){if(n.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");r=void 0===n.content||i?n.content+r:btoa(atob(n.content)+atob(r)),s=n.ctime}t={path:e,folder:a,type:"file",size:r.length,ctime:s,mtime:o,content:r};await this.dbRequest("put",[t])}async deleteFile(t){t=this.getPath(t.directory,t.path);if(void 0===await this.dbRequest("get",[t]))throw Error("File does not exist.");if(0!==(await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(t)])).length)throw Error("Folder is not empty.");await this.dbRequest("delete",[t])}async mkdir(t){const e=this.getPath(t.directory,t.path),r=t.recursive,i=e.substr(0,e.lastIndexOf("/")),a=(e.match(/\//g)||[]).length,o=await this.dbRequest("get",[i]),s=await this.dbRequest("get",[e]);if(1===a)throw Error("Cannot create Root directory");if(void 0!==s)throw Error("Current directory does already exist.");if(!r&&2!==a&&void 0===o)throw Error("Parent directory must exist");if(r&&2!==a&&void 0===o){const e=i.substr(i.indexOf("/",1));await this.mkdir({path:e,directory:t.directory,recursive:r})}t=Date.now(),t={path:e,folder:i,type:"directory",size:0,ctime:t,mtime:t};await this.dbRequest("put",[t])}async rmdir(t){var{path:e,directory:r,recursive:i}=t,t=this.getPath(r,e),a=await this.dbRequest("get",[t]);if(void 0===a)throw Error("Folder does not exist.");if("directory"!==a.type)throw Error("Requested path is not a directory");a=await this.readdir({path:e,directory:r});if(0!==a.files.length&&!i)throw Error("Folder is not empty");for(const o of a.files){const t=e+"/"+o.name;"file"===(await this.stat({path:t,directory:r})).type?await this.deleteFile({path:t,directory:r}):await this.rmdir({path:t,directory:r,recursive:i})}await this.dbRequest("delete",[t])}async readdir(t){const r=this.getPath(t.directory,t.path),e=await this.dbRequest("get",[r]);if(""!==t.path&&void 0===e)throw Error("Folder does not exist.");t=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(r)]);return{files:await Promise.all(t.map(async t=>{let e=await this.dbRequest("get",[t]);return void 0===e&&(e=await this.dbRequest("get",[t+"/"])),{name:t.substring(r.length+1),type:e.type,size:e.size,ctime:e.ctime,mtime:e.mtime,uri:e.path}}))}}async getUri(t){t=this.getPath(t.directory,t.path);let e=await this.dbRequest("get",[t]);return{uri:(null==(e=void 0===e?await this.dbRequest("get",[t+"/"]):e)?void 0:e.path)||t}}async stat(t){t=this.getPath(t.directory,t.path);let e=await this.dbRequest("get",[t]);if(void 0===(e=void 0===e?await this.dbRequest("get",[t+"/"]):e))throw Error("Entry does not exist.");return{type:e.type,size:e.size,ctime:e.ctime,mtime:e.mtime,uri:e.path}}async rename(t){await this._copy(t,!0)}async copy(t){return this._copy(t,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(e,r=!1){let i=e["toDirectory"];var{to:a,from:o,directory:s}=e;if(!a||!o)throw Error("Both to and from must be provided");i=i||s;const n=this.getPath(s,o),d=this.getPath(i,a);if(n!==d){if(function(t,e){t=u(t),e=u(e);const r=t.split("/"),i=e.split("/");return t!==e&&r.every((t,e)=>t===i[e])}(n,d))throw Error("To path cannot contain the from path");let t;try{t=await this.stat({path:a,directory:i})}catch(t){const e=a.split("/"),u=(e.pop(),e.join("/"));if(0<e.length&&"directory"!==(await this.stat({path:u,directory:i})).type)throw new Error("Parent directory of the to path is a file")}if(t&&"directory"===t.type)throw new Error("Cannot overwrite a directory with a file");var c=await this.stat({path:o,directory:s}),h=async(t,e,r)=>{t=this.getPath(i,t),t=await this.dbRequest("get",[t]);t.ctime=e,t.mtime=r,await this.dbRequest("put",[t])},l=c.ctime||Date.now();switch(c.type){case"file":{const e=await this.readFile({path:o,directory:s});let t;r&&await this.deleteFile({path:o,directory:s}),e.data instanceof Blob||this.isBase64String(e.data)||(t=y.UTF8);const n=await this.writeFile({path:a,directory:i,data:e.data,encoding:t});return r&&await h(a,l,c.mtime),n}case"directory":{if(t)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:a,directory:i,recursive:!1}),r&&await h(a,l,c.mtime)}catch(t){}const e=(await this.readdir({path:o,directory:s})).files;for(const u of e)await this._copy({from:o+"/"+u.name,to:a+"/"+u.name,directory:s,toDirectory:i},r);r&&await this.rmdir({path:o,directory:s})}}}return{uri:d}}isBase64String(t){try{return btoa(atob(t))==t}catch(t){return!1}}}t("FilesystemWeb",i),i._debug=!0}}});