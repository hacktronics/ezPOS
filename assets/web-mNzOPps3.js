import{W as P,D as x,E}from"./index-DZpm7Dsx.js";function m(t){const e=t.split("/").filter(t=>"."!==t),r=[];return e.forEach(t=>{".."===t&&0<r.length&&".."!==r[r.length-1]?r.pop():r.push(t)}),r.join("/")}function R(t,e){t=m(t),e=m(e);const r=t.split("/"),i=e.split("/");return t!==e&&r.every((t,e)=>t===i[e])}class g extends P{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"],this.downloadFile=async r=>{var i=x(r,r.webFetchExtra),i=await fetch(r.url,i);let a;if(r.progress)if(null!=i&&i.body){var o=i.body.getReader();let t=0;for(var s=[],n=i.headers.get("content-type"),d=parseInt(i.headers.get("content-length")||"0",10);;){var{done:c,value:h}=await o.read();if(c)break;s.push(h),t+=(null==h?void 0:h.length)||0;c={url:r.url,bytes:t,contentLength:d};this.notifyListeners("progress",c)}var l=new Uint8Array(t);let e=0;for(const y of s)"u"<typeof y||(l.set(y,e),e+=y.length);a=new Blob([l.buffer],{type:n||void 0})}else a=new Blob;else a=await i.blob();return{path:(await this.writeFile({path:r.path,directory:null!=(n=r.directory)?n:void 0,recursive:null!=(i=r.recursive)&&i,data:a})).uri,blob:a}}}async initDb(){if(void 0!==this._db)return this._db;if("indexedDB"in window)return new Promise((t,e)=>{const r=indexedDB.open(this.DB_NAME,this.DB_VERSION);r.onupgradeneeded=g.doUpgrade,r.onsuccess=()=>{this._db=r.result,t(r.result)},r.onerror=()=>e(r.error),r.onblocked=()=>{console.warn("db blocked")}});throw this.unavailable("This browser doesn't support IndexedDB")}static doUpgrade(t){var e=t.target.result;t.oldVersion,e.objectStoreNames.contains("FileStorage")&&e.deleteObjectStore("FileStorage"),e.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}async dbRequest(a,o){const s=-1!==this._writeCmds.indexOf(a)?"readwrite":"readonly";return this.initDb().then(i=>new Promise((t,e)=>{const r=i.transaction(["FileStorage"],s).objectStore("FileStorage")[a](...o);r.onsuccess=()=>t(r.result),r.onerror=()=>e(r.error)}))}async dbIndexRequest(a,o,s){const n=-1!==this._writeCmds.indexOf(o)?"readwrite":"readonly";return this.initDb().then(i=>new Promise((t,e)=>{const r=i.transaction(["FileStorage"],n).objectStore("FileStorage").index(a)[o](...s);r.onsuccess=()=>t(r.result),r.onerror=()=>e(r.error)}))}getPath(t,e){var r=void 0!==e?e.replace(/^[/]+|[/]+$/g,""):"";let i="";return void 0!==t&&(i+="/"+t),""!==e&&(i+="/"+r),i}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(t){t=this.getPath(t.directory,t.path),t=await this.dbRequest("get",[t]);if(void 0===t)throw Error("File does not exist.");return{data:t.content||""}}async writeFile(t){var e=this.getPath(t.directory,t.path);let r=t.data;var i=t.encoding,a=t.recursive,o=await this.dbRequest("get",[e]);if(o&&"directory"===o.type)throw Error("The supplied path is a directory.");var s,o=e.substr(0,e.lastIndexOf("/"));if(void 0===await this.dbRequest("get",[o])&&-1!==(s=o.indexOf("/",1))&&(s=o.substr(s),await this.mkdir({path:s,directory:t.directory,recursive:a})),i||r instanceof Blob||(r=0<=r.indexOf(",")?r.split(",")[1]:r,this.isBase64String(r)))return s=Date.now(),t={path:e,folder:o,type:"file",size:r instanceof Blob?r.size:r.length,ctime:s,mtime:s,content:r},await this.dbRequest("put",[t]),{uri:t.path};throw Error("The supplied data is not valid base64 content.")}async appendFile(t){var e=this.getPath(t.directory,t.path);let r=t.data;var i=t.encoding,a=e.substr(0,e.lastIndexOf("/")),o=Date.now();let s=o;var n=await this.dbRequest("get",[e]);if(n&&"directory"===n.type)throw Error("The supplied path is a directory.");if(void 0===await this.dbRequest("get",[a])&&-1!==(d=a.indexOf("/",1))&&(d=a.substr(d),await this.mkdir({path:d,directory:t.directory,recursive:!0})),!i&&!this.isBase64String(r))throw Error("The supplied data is not valid base64 content.");if(void 0!==n){if(n.content instanceof Blob)throw Error("The occupied entry contains a Blob object which cannot be appended to.");r=void 0===n.content||i?n.content+r:btoa(atob(n.content)+atob(r)),s=n.ctime}var d={path:e,folder:a,type:"file",size:r.length,ctime:s,mtime:o,content:r};await this.dbRequest("put",[d])}async deleteFile(t){t=this.getPath(t.directory,t.path);if(void 0===await this.dbRequest("get",[t]))throw Error("File does not exist.");if(0!==(await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(t)])).length)throw Error("Folder is not empty.");await this.dbRequest("delete",[t])}async mkdir(t){var e=this.getPath(t.directory,t.path),r=t.recursive,i=e.substr(0,e.lastIndexOf("/")),a=(e.match(/\//g)||[]).length,o=await this.dbRequest("get",[i]),s=await this.dbRequest("get",[e]);if(1===a)throw Error("Cannot create Root directory");if(void 0!==s)throw Error("Current directory does already exist.");if(!r&&2!==a&&void 0===o)throw Error("Parent directory must exist");r&&2!==a&&void 0===o&&(s=i.substr(i.indexOf("/",1)),await this.mkdir({path:s,directory:t.directory,recursive:r}));a=Date.now();await this.dbRequest("put",[{path:e,folder:i,type:"directory",size:0,ctime:a,mtime:a}])}async rmdir(t){var{path:e,directory:r,recursive:i}=t,t=this.getPath(r,e),a=await this.dbRequest("get",[t]);if(void 0===a)throw Error("Folder does not exist.");if("directory"!==a.type)throw Error("Requested path is not a directory");a=await this.readdir({path:e,directory:r});if(0!==a.files.length&&!i)throw Error("Folder is not empty");for(const s of a.files){var o="".concat(e,"/").concat(s.name);"file"===(await this.stat({path:o,directory:r})).type?await this.deleteFile({path:o,directory:r}):await this.rmdir({path:o,directory:r,recursive:i})}await this.dbRequest("delete",[t])}async readdir(t){const r=this.getPath(t.directory,t.path),e=await this.dbRequest("get",[r]);if(""!==t.path&&void 0===e)throw Error("Folder does not exist.");t=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(r)]);return{files:await Promise.all(t.map(async t=>{let e=await this.dbRequest("get",[t]);return void 0===e&&(e=await this.dbRequest("get",[t+"/"])),{name:t.substring(r.length+1),type:e.type,size:e.size,ctime:e.ctime,mtime:e.mtime,uri:e.path}}))}}async getUri(t){t=this.getPath(t.directory,t.path);let e=await this.dbRequest("get",[t]);return{uri:(null==(e=void 0===e?await this.dbRequest("get",[t+"/"]):e)?void 0:e.path)||t}}async stat(t){t=this.getPath(t.directory,t.path);let e=await this.dbRequest("get",[t]);if(void 0===(e=void 0===e?await this.dbRequest("get",[t+"/"]):e))throw Error("Entry does not exist.");return{type:e.type,size:e.size,ctime:e.ctime,mtime:e.mtime,uri:e.path}}async rename(t){await this._copy(t,!0)}async copy(t){return this._copy(t,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(e,r=!1){let i=e["toDirectory"];var{to:a,from:o,directory:s}=e;if(!a||!o)throw Error("Both to and from must be provided");i=i||s;var e=this.getPath(s,o),n=this.getPath(i,a);if(e!==n){if(R(e,n))throw Error("To path cannot contain the from path");let t;try{t=await this.stat({path:a,directory:i})}catch(t){var e=a.split("/"),d=(e.pop(),e.join("/"));if(0<e.length&&"directory"!==(await this.stat({path:d,directory:i})).type)throw new Error("Parent directory of the to path is a file")}if(t&&"directory"===t.type)throw new Error("Cannot overwrite a directory with a file");var c=await this.stat({path:o,directory:s}),h=async(t,e,r)=>{t=this.getPath(i,t),t=await this.dbRequest("get",[t]);t.ctime=e,t.mtime=r,await this.dbRequest("put",[t])},l=c.ctime||Date.now();switch(c.type){case"file":{var y=await this.readFile({path:o,directory:s});r&&await this.deleteFile({path:o,directory:s});let t;y.data instanceof Blob||this.isBase64String(y.data)||(t=E.UTF8);y=await this.writeFile({path:a,directory:i,data:y.data,encoding:t});return r&&await h(a,l,c.mtime),y}case"directory":if(t)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:a,directory:i,recursive:!1}),r&&await h(a,l,c.mtime)}catch(t){}for(const u of(await this.readdir({path:o,directory:s})).files)await this._copy({from:"".concat(o,"/").concat(u.name),to:"".concat(a,"/").concat(u.name),directory:s,toDirectory:i},r);r&&await this.rmdir({path:o,directory:s})}}return{uri:n}}isBase64String(t){try{return btoa(atob(t))==t}catch(t){return!1}}}g._debug=!0;export{g as FilesystemWeb};